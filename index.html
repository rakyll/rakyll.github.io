<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.18-DEV" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  
  <title>Go, the unwritten parts</title>
  

  
  <link rel="stylesheet" href="https://rakyll.org/css/poole.css">
  <link rel="stylesheet" href="https://rakyll.org/css/syntax.css">
  <link rel="stylesheet" href="https://rakyll.org/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" type="image/png" href="/favicon.png">

  
  <link href="https://rakyll.org/index.xml" rel="alternate" type="application/rss+xml" title="Go, the unwritten parts" />
</head>

<body class=" layout-reverse">

<div class="sidebar">
  <div class="container sidebar-sticky">


    <div class="sidebar-about">
      <a href="https://rakyll.org/"><h1>Go, the unwritten parts</h1></a>
      <p class="lead">
      Articles mostly about what's coming up with the next Go release.
      Conventions, best practices, little known practical tips.
      </p>
      <p>Written by <a href="https://twitter.com/rakyll">@rakyll</a>.</p>
    </div>

    <ul class="sidebar-nav">
      
      <li><a href="/">Home</a> </li>
      <li><a href="/archive/">Archive</a></li>
      <li><a href="/about/">About</a></li>
      <li><a href="https://github.com/rakyll/">GitHub</a></li>
      
    </ul>

    <p class="small">
      This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
      The blog is served by the amazing <a href="https://gohugo.io">Hugo</a>.
    </p>
  </div>
</div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-83257159-1', 'auto');
  ga('send', 'pageview');

</script>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
<script type="text/javascript">
function linkify(i) {
  console.log(i, el);
  var id = this.id();
  this.html("hehehe");
}

$(document).ready(function() {
  $("h2").each(linkify);
  $("h3").each(linkify);
  $("h4").each(linkify);
});

</script>

    <div class="content container">
<div class="posts">


  
  <div class="post">
    <h1 class="post-title">
      <a href="https://rakyll.org/naming-tests-to-doc/">
        Naming tests to self-document
      </a>
    </h1>

    <span class="post-date">Fri, Feb 3, 2017</span>

    <p>Go doesn&rsquo;t specifically enforce you how you choose your test names.
Tests are a significant contributors for the maintainability
of your code. Tests not just providing correctness checking
but also are useful in self documenting your code and its usage.
On top of that, tests are the single best source to read about
responsbilities of a type, function, etc.
This is where naming tests better can help the internal documentation
and therefore the maintainability of your code.</p>

<p>Emphasize the role of what you are testing rather than naming
after the inputs and outputs.</p>

<pre><code class="language-wrong">func TestTitleIllegalChar(t *testing.T) {}
</code></pre>

<p>Instead, explain that the doc needs to be able to escape illegal
characters on edit.</p>

<pre><code>func TestTitleEscape(t *testing.T) {}
</code></pre>

<p>With this rename, we also self-document how the illegal characters
on the title will be handled.</p>

<p>We sometimes pick very inclusive test names and write big table-driven
tests. If you are running table-driven tests, you can convert them to
<a href="https://blog.golang.org/subtests">subtests</a> and name the individual cases.
Then <code>go test -v</code> can pick those name and its output will act as a spec of
your type, function, etc.</p>


  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://rakyll.org/style-packages/">
        Style guideline for Go packages
      </a>
    </h1>

    <span class="post-date">Sat, Jan 14, 2017</span>

    

<p>Go is about naming and organization as much as everything else in the language.
Well-organized Go code is easy to discover,
use and read. Well-organized code is as critical as well designed APIs. The location, name,
and the structure of your packages are the first elements your users see and interact with.</p>

<p>This document&rsquo;s goal is to guide you with common good practices not to set rules.
You will always need to use your own judgement to pick the most elegant solution
for your specific case.</p>

<h2 id="packages">Packages</h2>

<p>All Go code is organized into packages. A package in Go is simply a directory/folder with one or more
<code>.go</code> files inside of it. Go packages provide isolation and organization of code similar to
how directories/folders organize files on a computer.</p>

<p>All Go code lives in a package and a package is the entry point to access Go code. Understanding
and establishing good practices around packages is important to write effective Go code.</p>

<hr />

<h2 id="package-organization">Package Organization</h2>

<p>Let&rsquo;s begin with suggestions how you should organize Go code and explain conventions about
locating Go packages.</p>

<h3 id="use-multiple-files">Use multiple files</h3>

<p>A package is a directory with one or more Go files.
Feel free to separate your code into as many files as logically
make sense for optimal readability.</p>

<p>For example, an HTTP package might have been separated into different files
according to the HTTP aspect the file handles.
In the following example, an HTTP package is broken down into a few files:
header types and code, cookie types and code, the actual HTTP implementation, and
documentation of the package.</p>

<pre><code>- doc.go       // package documentation
- headers.go   // HTTP headers types and code
- cookies.go   // HTTP cookies types and code
- http.go      // HTTP client implementation, request and response types, etc.
</code></pre>

<h3 id="keep-types-close">Keep types close</h3>

<p>As a rule of thumb, keep types closer to where they are used. This makes it easy for
any maintainer (not just the original author) to find a type.
A good place for a Header struct type might be in <code>headers.go</code>.</p>

<pre><code>$ cat headers.go
package http

// Header represents an HTTP header.
type Header struct {...}
</code></pre>

<p>Even though, the Go language doesn&rsquo;t restrict where you define types,
it is often a good practice to keep the core types grouped at the top of a file.</p>

<h3 id="organize-by-responsbility">Organize by responsbility</h3>

<p>A common practise from other languages is to organize types together in a package
called models or types. In Go, we organize code by their functional responsibilities.</p>

<pre><code class="language-wrong">package models // DON'T DO IT!!!

// User represents a user in the system.
type User struct {...}
</code></pre>

<p>Rather than creating a models package and declare all entity types there,
a User type should live in a user package that provides everything related to users.</p>

<pre><code>package user

// User represents a user in the system.
type User struct {...}

func QueryUsers(ctx context.Context, q *Query) ([]*User, *Iterator, error)
</code></pre>

<h3 id="optimize-for-godoc">Optimize for godoc</h3>

<p>It is a great exercise to use godoc in the early phases of your package&rsquo;s API design to see
how your concepts will be rendered on doc. Sometimes, the visualization also has an impact
on the design. Godoc is the way your users will consume a package, so it is ok to tweak
things to make them more accessible. Run <code>godoc -http=&lt;hostport&gt;</code> to start a godoc server locally.</p>

<h3 id="provide-examples-to-fill-the-gaps">Provide examples to fill the gaps</h3>

<p>In some cases, you may not be able to provide all related types from a single package. It might be noisy
to do so, or you might want to publish concrete implementations of a common interface from a separate
package, or those types could be owned by a third-party package.
Give examples to help the user to discover and understand how they are used together.</p>

<pre><code>$ godoc cloud.google.com/go/datastore
func NewClient(ctx context.Context, projectID string, opts ...option.ClientOption) (*Client, error)
...
</code></pre>

<p>NewClient works with option.ClientOptions but it is neither the datastore package
nor the option package that export all the option types.</p>

<pre><code>$ godoc google.golang.org/extraoption
func WithCustomValue(v string) option.ClientOption
...
</code></pre>

<p>If your API requires many non-standard packages to be imported, it is often useful to add
a <a href="https://blog.golang.org/examples">Go example</a> to give your users some working code.</p>

<p>Examples are a good way to increase visibility of a less discoverable package.
For example, an example for datastore.NewClient might reference the extraoption package.</p>

<h3 id="don-t-export-from-main">Don&rsquo;t export from main</h3>

<p>An identifier may be <a href="https://golang.org/ref/spec#Exported_identifiers">exported</a>
to permit access to it from another package.</p>

<p>Main packages are not importable, so exporting identifiers from main packages is unnecessary.
Don&rsquo;t export identifiers from a main package if you are building the package to a binary.</p>

<p>Exceptions to this rule might be the main packages built into a .so, or a .a or Go plugin.
In such cases, Go code might be used from other languages via
<a href="https://golang.org/cmd/cgo/#hdr-C_references_to_Go">cgo&rsquo;s export functionality</a>
and exporting identifiers are required.</p>

<hr />

<h2 id="package-naming">Package Naming</h2>

<p>A package name and import path are both significant identifiers of your package
and represent everything your package contains. Naming your packages canonically
not just improves your code quality but also your users&rsquo;.</p>

<h3 id="lowercase-only">Lowercase only</h3>

<p>Package names should be lowercase. Don&rsquo;t use snake_case or camelCase in package names.
The Go blog has a <a href="https://blog.golang.org/package-names">comprehensive guide</a> about naming packages
with a good variety of examples.</p>

<h3 id="short-but-representative-names">Short, but representative names</h3>

<p>Package names should be short, but should be unique and representative.
Users of the package should be able to grasp its purpose from just the package&rsquo;s name.</p>

<p>Avoid overly broad package names like &ldquo;common&rdquo; and &ldquo;util&rdquo;.</p>

<pre><code class="language-wrong">import &quot;pkgs.org/common&quot; // DON'T!!!
</code></pre>

<p>Avoid duplicate names in cases where user may need to import the same package.</p>

<p>If you cannot avoid a bad name, it is very likely that there is a problem
with your overall structure and code organization.</p>

<h3 id="clean-import-paths">Clean import paths</h3>

<p>Avoid exposing your custom repository structure to your users. Align
well with the GOPATH conventions. Avoid having src/, pkg/
sections in your import paths.</p>

<pre><code class="language-wrong">github.com/user/repo/src/httputil   // DON'T DO IT, AVOID SRC!!

github.com/user/repo/gosrc/httputil // DON'T DO IT, AVOID GOSRC!!
</code></pre>

<h3 id="no-plurals">No plurals</h3>

<p>In go, package names are not plural. This is surprising to programmers who came
from other languages and are retaining an old habit of pluralizing names.
Don&rsquo;t name a package httputils, but httputil!</p>

<pre><code class="language-wrong">package httputils  // DON'T DO IT, USE SINGULAR FORM!!
</code></pre>

<h3 id="renames-should-follow-the-same-rules">Renames should follow the same rules</h3>

<p>If you are importing more than one packages with the same name, you can locally
rename the package names. The renames should follow the same rules mentioned
on this article. There is no rule which package you should rename. If you are
renaming the standard package library, it is nice to add a go prefix to make the name
self document that it is &ldquo;Go standard library&rsquo;s&rdquo; package, e.g. <code>gourl</code>, <code>goioutil</code>.</p>

<pre><code>import (
    gourl &quot;net/url&quot;

    &quot;myother.com/url&quot;
)
</code></pre>

<h3 id="enforce-vanity-urls">Enforce vanity URLs</h3>

<p><code>go get</code> supports getting packages by a URL that is different than the URL
of the package&rsquo;s repo. These URLs are called vanity URLs and require you to
serve a page with specific meta tags the Go tools recognize.
You can serve a package with a custom domain and path using vanity URLs.</p>

<p>For example,</p>

<pre><code>$ go get cloud.google.com/go/datastore
</code></pre>

<p>checks out the source code from <code>https://code.googlesource.com/gocloud</code> behind
the scenes and puts it in your workspace under $GOPATH/src/cloud.google.com/go/datastore.</p>

<p>Given code.googlesource.com/gocloud is already serving this package, would it
be possible to go get the package from that URL? The answer is no, if you enforce
the vanity URL.</p>

<p>To do that, add an import statement to the package. The go tool will reject
any import of this package from any other path and will display a friendly
error to the user. If you don&rsquo;t enforce your vanity URLs, there will be two
copies of your package that cannot work together due to the different namespace.</p>

<pre><code>package datastore // import &quot;cloud.google.com/go/datastore&quot;
</code></pre>

<hr />

<h2 id="package-documentation">Package Documentation</h2>

<p>Always document the package. Package documentation is a top-level comment
immediately preceding the package clause. For non-main packages, godoc always starts with
&ldquo;Package {pkgname}&rdquo; and follows with a description. For main packages, documentation
should explain the binary.</p>

<pre><code>// Package ioutil implements some I/O utility functions.
package ioutil

// Command gops lists all the processes running on your system.
package main

// Sample helloworld demonstrates how to use x.
package main
</code></pre>

<h3 id="use-doc-go">Use doc.go</h3>

<p>Sometimes, package docs can get very lengthy, especially when they provide details
of usage and guidelines.
Move the package godoc to a <code>doc.go</code> file.
(See an example of a <a href="https://github.com/GoogleCloudPlatform/google-cloud-go/blob/master/datastore/doc.go">doc.go</a>.)</p>


  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://rakyll.org/go18cls/">
        Go 1.8 development stats
      </a>
    </h1>

    <span class="post-date">Wed, Jan 11, 2017</span>

    

<p>Go 1.8 is going to to launched in February 2017. There is a sizable list of
<a href="https://beta.golang.org/doc/go1.8">new features and improvements</a> on the release notes.
While these notes is the best summary to see what has happened in the last 6 months,
I will try to give you some stats to give you a sense of the size of the work.
I have examined all the changes merged into the tree during the Go 1.8 window and
will highligth the some of the interesting and significant ones.</p>

<p>There has been 2049 commits I have examined to gather these results.
<a href="https://go-review.googlesource.com/#/c/35111/">c/35111</a> is the last commit
I have included in the data set.</p>

<h2 id="contributors">Contributors</h2>

<p>There have been 201 contributors involved during the development of 1.8 </p>

<p>But, more than 55% of the commits came from the top 10 contributors.</p>

<pre><code>| Author               | Changes |
|----------------------|---------|
| Brad Fitzpatrick     | 225     |
| Russ Cox             | 140     |
| Josh Bleecher Snyder | 137     |
| Robert Griesemer     | 129     |
| Ian Lance Taylor     | 117     |
| Austin Clements      | 111     |
| Matthew Dempsky      | 94      |
| David Crawshaw       | 69      |
| Keith Randall        | 65      |
| Cherry Zhang         | 55      |
</code></pre>

<p>There is only one non-Googler in the top 10, Josh Bleecher Snyder.</p>

<h2 id="reviews">Reviews</h2>

<p>Go has a reputation of having comphensive and throughtful code reviewing.
Each change list needs at least one reviewer, for controversial topics the number grows easily.
The average number of reviewers for each change was 3.41 people during this cycle.</p>

<p>1160 changes got a LGTM without anyone requiring to leave any comment,
most of these changes are coming from already tenured contributors.</p>

<p>There also have been noiser changes. Top three of them with most reviewers are:</p>

<ul>
<li><a href="https://go-review.googlesource.com/#/c/16551/">c/16551</a>: Addition of os.Executable</li>
<li><a href="https://go-review.googlesource.com/#/c/29397/">c/29397</a>: Far jumps are handled on ARM, big ARM binaries are fine now.</li>
<li><a href="https://go-review.googlesource.com/#/c/32019/">c/32019</a>: Implementation of the default GOPATH</li>
</ul>

<p>The average number of comments left on a change is 3.51.</p>

<p>Half of the changes took 8 hours or less to submit from its creation.
Of course, there been some long standing changes that have waited for long
(even for a year) and finally made their way to this release but the
review stage has been quite productive in most cases.</p>

<h2 id="size">Size</h2>

<p>The size of a change is the sum of lines added and lines deleted.
Average size for a change during 1.8 development was 190.73 lines.
If you look at the distribution though, half of the changes are
smaller than 25 lines.</p>

<h3 id="the-biggest-changes">The biggest changes</h3>

<p>Most sizeable changes are often going to the compiler. Here are the top 3 biggest changes in 1.8:</p>

<ul>
<li><a href="https://go-review.googlesource.com/#/c/29168/">c/29168</a>: Deletion of the old compiler backend</li>
<li><a href="https://go-review.googlesource.com/#/c/28978/">c/28978</a>: SSA backend for s390x</li>
<li><a href="https://go-review.googlesource.com/#/c/31478/">c/31478</a>: SSA backend for mips</li>
</ul>

<h3 id="minor-fixes">Minor fixes</h3>

<p>How many times you have spotted a problem but ignored it because you were ashamed
of openining a single line commit? There are 390 changes that are under 5 lines in 1.8.
There is no such thing called little contribution in Go, almost 20% of the
changes were teeny-tiny.</p>


  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://rakyll.org/mutexprofile/">
        Mutex profile
      </a>
    </h1>

    <span class="post-date">Mon, Dec 19, 2016</span>

    <p>Go 1.8 introduces a new profile, the contended mutex profile, that allows you to
capture a fraction of the stack traces of goroutines with contended mutexes.</p>

<p>You need to set the sampling fraction by calling
<a href="http://beta.golang.org/pkg/runtime/#SetMutexProfileFraction">runtime.SetMutexProfileFraction</a>
to a value above zero to enable collection.</p>

<p>Consider the following program:</p>

<pre><code>import _ &quot;net/http/pprof&quot;

var mu sync.Mutex
var items = make(map[int]struct{})

runtime.SetMutexProfileFraction(5)
for i := 0; i &lt; 1000*1000; i++ {
    go func(i int) {
        mu.Lock()
        defer mu.Unlock()

        items[i] = struct{}{}
    }(i)
}

http.ListenAndServe(&quot;:8888&quot;, nil)
</code></pre>

<p>Run the program, <a href="http://localhost:8888/debug/pprof/mutex?debug=1">http://localhost:8888/debug/pprof/mutex</a> will
serve the mutex profile. Then, you can use <code>go tool pprof</code> to examine the profile.</p>

<pre><code>$ go tool pprof &lt;binary&gt; http://localhost:8888/debug/pprof/mutex?debug=1
Fetching profile from http://localhost:8888/debug/pprof/mutex
Saved profile in /Users/jbd/pprof/pprof.mutexprofile.localhost:8888.contentions.delay.002.pb.gz
Entering interactive mode (type &quot;help&quot; for commands)
(pprof) list
Total: 27.15s
ROUTINE ======================== main.main.func1 in /Users/jbd/src/hello/mutexprofile/main.go
         0     27.15s (flat, cum)   100% of Total
         .          .     18:		go func() {
         .          .     19:			mu.Lock()
         .          .     20:			defer mu.Unlock()
         .          .     21:
         .          .     22:			items[i] = struct{}{}
         .     27.15s     23:		}()
         .          .     24:	}
         .          .     25:	http.ListenAndServe(&quot;:8888&quot;, nil)
         .          .     26:}
ROUTINE ======================== runtime.goexit in /Users/jbd/go/src/runtime/asm_amd64.s
         0     27.15s (flat, cum)   100% of Total
         .          .   2179:	RET
         .          .   2180:
         .          .   2181:// The top-most function running on a goroutine
         .          .   2182:// returns to goexit+PCQuantum.
         .          .   2183:TEXT runtime路goexit(SB),NOSPLIT,$0-0
         .     27.15s   2184:	BYTE	$0x90	// NOP
         .          .   2185:	CALL	runtime路goexit1(SB)	// does not return
         .          .   2186:	// traceback from goexit1 must hit code range of goexit
         .          .   2187:	BYTE	$0x90	// NOP
         .          .   2188:
         .          .   2189:TEXT runtime路prefetcht0(SB),NOSPLIT,$0-8
ROUTINE ======================== sync.(*Mutex).Unlock in /Users/jbd/go/src/sync/mutex.go
    27.15s     27.15s (flat, cum)   100% of Total
         .          .    121:			return
         .          .    122:		}
         .          .    123:		// Grab the right to wake someone.
         .          .    124:		new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken
         .          .    125:		if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
    27.15s     27.15s    126:			runtime_Semrelease(&amp;m.sema)
         .          .    127:			return
         .          .    128:		}
         .          .    129:		old = m.state
         .          .    130:	}
         .          .    131:}
</code></pre>

<p>The fraction is automatically set in tests if <code>-mutexprofile</code> is used. Set
the flag to write the profile to a file.</p>

<pre><code>go test -mutexprofile=mutex.out
</code></pre>

<p>Then, the pprof tool can be used to examine the recorded profile.</p>

<pre><code>go tool pprof &lt;test.binary&gt; mutex.out
</code></pre>

<p>See the <a href="http://beta.golang.org/pkg/runtime/pprof/">runtime/pprof</a> package for more details about profiling
and the predefined profiles.</p>

<p><a href="https://talks.golang.org/2017/state-of-go.slide#23">The State of the Go 2017 talk</a>
also contains a guide how to run benchmarks while capturing the mutex profile. It is worth to take a
look if you are willing to write benchmarks.</p>

<p>Happy profiling!</p>


  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://rakyll.org/default-gopath/">
        The default GOPATH
      </a>
    </h1>

    <span class="post-date">Wed, Dec 14, 2016</span>

    <p>Go 1.8 will set a default GOPATH if the GOPATH env variable is not set.</p>

<p>The requirement of setting a GOPATH has been a major issue for Go users
who installed the Go tools for the first time and got the
&ldquo;you have to set a GOPATH&rdquo; error in their initial experience with the tools.
Explaining the GOPATH is and instructing how to set this env variable were both
distracting new users away from using Go. This was especially true for users who
are not necessarily developing in Go but using <code>go get</code> to download commands.</p>

<p>Go 1.8 is introducing a <a href="https://github.com/golang/go/issues/17262">default GOPATH</a>.
If you don&rsquo;t set one, the tools will use the default. Default GOPATH is:</p>

<ul>
<li>$HOME/go on Unix-like systems</li>
<li>%USERPROFILE%\go on Windows</li>
</ul>

<p>Even though you don&rsquo;t have care about setting this variable, there are few items
that still requires your attention.</p>

<ul>
<li>Users still need to add $GOPATH/bin into their PATH to run binaries installed by
<code>go get</code> and <code>go install</code>.</li>
<li>The users who are developing with the Go language still need to understand
that the presence of GOPATH, its location and its structure.</li>
<li>If your GOROOT (the location where you checkout the Go&rsquo;s source code)
is the default GOPATH and if you don&rsquo;t have a GOPATH set, the
tools will reject to use the default GOPATH not to corrupt your GOROOT.</li>
</ul>

<p>You still may prefer to <a href="https://golang.org/wiki/SettingGOPATH">set a custom GOPATH</a>
if the default is not working for you.</p>

<p>If a custom GOPATH is set, <code>go env GOPATH</code> will report its value.</p>


  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://rakyll.org/http2push/">
        HTTP/2 Server Push
      </a>
    </h1>

    <span class="post-date">Sat, Dec 10, 2016</span>

    <p>Go 1.8 is going to feature support for HTTP/2 server push.</p>

<p>HTTP/2 has many features designed to make the Web faster. One of those features
is the server push, the ability to send resources before the client asks for it.
This feature enables websites to push assets like JavaScript and CSS files
before waiting for the web page to be loaded and asking for those resources.</p>

<p><code>net/http</code> package will support server push by exposing a <a href="https://tip.golang.org/pkg/net/http/#Pusher">Pusher API</a>
that will be supported by HTTP/2 ResponseWriters. This interface is only implemented when HTTP/2 is available.</p>

<p>In the following handler, we will push <code>main.js</code> rather than waiting for the page to load
and inkove the request itself.</p>

<pre><code class="language-go">const indexHTML = `&lt;html&gt;
&lt;head&gt;
	&lt;title&gt;Hello&lt;/title&gt;
	&lt;script src=&quot;/main.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
`

http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) {
    if r.URL.Path != &quot;/&quot; {
        http.NotFound(w, r)
        return
    }
    pusher, ok := w.(http.Pusher)
    if ok { // Push is supported. Try pushing rather than waiting for the browser.
        if err := pusher.Push(&quot;/main.js&quot;, nil); err != nil {
            log.Printf(&quot;Failed to push: %v&quot;, err)
        }
    }
    fmt.Fprintf(w, indexHTML)
})
</code></pre>

<p>In the Network tab, you can see that the JavaScript file is loaded by server push rather
than a GET request.</p>

<p><img src="/img/http2push.png" alt="Push" /></p>

<p>Push support will be available in Go 1.8
that is available as <a href="(https://groups.google.com/forum/#!topic/golang-nuts/QYuo0fai6YE)">beta</a>,
download and give this a try. A full sample program can by found on <a href="https://gist.github.com/rakyll/eec415977f85d50a493ca8472ba97b68">this gist</a>.</p>


  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://rakyll.org/deprecated/">
        Deprecation notices in Go
      </a>
    </h1>

    <span class="post-date">Thu, Dec 8, 2016</span>

    <p>In Go, for a long time, we didn&rsquo;t have a convention to label the deprecated APIs.
In the past years, there is new convention emerged to add deprecation notices to the docs.</p>

<p>Today, standard library uses this specific format.</p>

<p>As an example, Go 1.8 deprecates <a href="https://tip.golang.org/pkg/database/sql/driver/#Execer"><code>sql/driver.Execer</code></a>
and adds a deprecation notice to its godoc.</p>

<pre><code>// Execer is an optional interface that may be implemented by a Conn.
//
// If a Conn does not implement Execer, the sql package's DB.Exec will
// first prepare a query, execute the statement, and then close the
// statement.
//
// Exec may return ErrSkip.
//
// Deprecated: Drivers should implement ExecerContext instead (or additionally).
type Execer interface {
	Exec(query string, args []Value) (Result, error)
}
</code></pre>

<p>The deprecation notice should be in the godoc, begin with string &ldquo;Deprecated: &ldquo; and follow with
a tip for replacement.</p>

<pre><code>// Deprecated: Use strings.HasPrefix instead.
</code></pre>

<p>User are expected to follow the tip and switch to the new recommended API.</p>

<p>Additional to the notices, there is an effort going on to discourage users
to keep depending on the deprecated APIs.</p>

<p>See the following items for the ongoing work:</p>

<ul>
<li><a href="https://github.com/golang/go/issues/17056">Proposal to hide deprecated APIs by default</a></li>
<li><a href="https://github.com/golang/gddo/issues/456">Hiding deprecated APIs on godoc.org</a></li>
<li><a href="https://github.com/golang/lint/issues/238">Reporting deprecated APIs with golint</a></li>
</ul>

<p>In conclusion, please use this specific format to add deprecation notices. Not &ldquo;DEPRECATED&rdquo; or
not &ldquo;This type is deprecated&rdquo;. Soon, you will be able to enjoy the tooling support that yells at your
users to stop depending on your deprecated APIs.</p>


  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://rakyll.org/leakingctx/">
        Using contexts to avoid leaking goroutines
      </a>
    </h1>

    <span class="post-date">Tue, Oct 25, 2016</span>

    <p>The <a href="https://godoc.org/pkg/context">context</a> package makes it possible
to manage a chain of calls within the same call path by signaling context&rsquo;s
Done channel.</p>

<p>In this article, we will examine how to use the context package to
avoid leaking goroutines.</p>

<p>Assume, you have a function that starts a goroutine internally. Once this
function is called, the caller may not be able to terminate the goroutine
started by the function.</p>

<pre><code class="language-go">// gen is a broken generator that will leak a goroutine.
func gen() &lt;-chan int {
	ch := make(chan int)
	go func() {
		var n int
		for {
			ch &lt;- n
			n++
		}
	}()
	return ch
}
</code></pre>

<p>The generator above starts a goroutine with an infinite loop,
but the caller consumes the values until n is equal to 5.</p>

<pre><code class="language-go">// The call site of gen doesn't have a 
for n := range gen() {
    fmt.Println(n)
    if n == 5 {
        break
    }
}
</code></pre>

<p>Once the caller is done with the generator (when it breaks the loop),
the goroutine will run forever executing the infinite loop. Our code
will leak a goroutine.</p>

<p>We can avoid the problem by signaling the internal goroutine with a
stop channel but there is a better solution: cancellable contexts.
The generator can select on a context&rsquo;s Done channel and once the context is
done, the internal goroutine can be cancelled.</p>

<pre><code class="language-go">// gen is a generator that can be cancellable by cancelling the ctx.
func gen(ctx context.Context) &lt;-chan int {
	ch := make(chan int)
	go func() {
		var n int
		for {
			select {
			case &lt;-ctx.Done():
				return // avoid leaking of this goroutine when ctx is done.
			case ch &lt;- n:
				n++
			}
		}
	}()
	return ch
}
</code></pre>

<p>Now, the caller can signal the generator when it is done consuming.
Once cancel function is called, the internal goroutine will be returned.</p>

<pre><code>ctx, cancel := context.WithCancel(context.Background())
defer cancel() // make sure all paths cancel the context to avoid context leak

for n := range gen(ctx) {
    fmt.Println(n)
    if n == 5 {
        cancel()
        break
    }
}

// ...
</code></pre>

<p>The full program is available as a <a href="https://gist.github.com/rakyll/1aa860377dab8fd445431bbb3204f600">gist</a>.</p>


  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://rakyll.org/codegen/">
        Debugging code generation in Go
      </a>
    </h1>

    <span class="post-date">Sat, Oct 15, 2016</span>

    

<p><em>Last week, I was at <a href="http://www.dotgo.eu/">dotGo</a>, participating one of the
finest Go conferences and catching up with gophers from the other side of the
Atlantic. I gave a very short lightning talk about inspection of code generation
with the tools alrady available in the toolchain. This post goes through the talk for
those who didn&rsquo;t have to priviledge to be at the conference. Slides are also
available at <a href="https://go-talks.appspot.com/github.com/rakyll/talks/gcinspect/talk.slide">go-talks</a>.</em></p>

<p>Through the article, we will use the following program:</p>

<pre><code>package main

import &quot;fmt&quot;

func main() {
    sum := 1 + 1
    fmt.Printf(&quot;sum: %v\n&quot;, sum)
}
</code></pre>

<h3 id="toolchain">Toolchain</h3>

<p>Go build is a command that encapsulates tons of things from the user.
But, it also provides more detailed information about what it does if you ask for it.
<code>-x</code> is a flag that makes go build output what is being invoked.
If you want to see what the components of the toolchain are,
which sequence they are invoked and which flags being used, use <code>-x</code>.</p>

<pre><code>$ go build -x
WORK=/var/folders/00/1b8h8000h01000cxqpysvccm005d21/T/go-build190726544
mkdir -p $WORK/hello/_obj/
mkdir -p $WORK/hello/_obj/exe/
cd /Users/jbd/src/hello
/Users/jbd/go/pkg/tool/darwin_amd64/compile -o $WORK/hello.a -trimpath $WORK -p main -complete -buildid d934a5702088e0fe5c931a55ff26bec87b80cbdc -D _/Users/jbd/src/hello -I $WORK -pack ./hello.go
cd .
/Users/jbd/go/pkg/tool/darwin_amd64/link -o $WORK/hello/_obj/exe/a.out -L $WORK -extld=clang -buildmode=exe -buildid=d934a5702088e0fe5c931a55ff26bec87b80cbdc $WORK/hello.a
mv $WORK/hello/_obj/exe/a.out hello
</code></pre>

<h3 id="intermediate-assembly">Intermediate assembly</h3>

<p>In Go, there is an intermediate assembly phase before generating the actual arch-specific assembly.
Compiler takes some Go files, generates the intermediate instructions and escalate it to the <code>obj</code> package to generate the machine code.
If you are curious about what compiler generates in this phase, <code>-S</code> makes the compiler dumps the output.</p>

<p>The intermediate assembly is generally good reference to understand the cost of a Go line.
Or it coulbe be a great reference if you want to replace, let&rsquo;s say, a Go function with more optimized assembly equivalent.</p>

<p>You are seeing the output for the main.main here.</p>

<pre><code>$ go build -gcflags=&quot;-S&quot;
# hello
&quot;&quot;.main t=1 size=179 args=0x0 locals=0x60
    0x0000 00000 (/Users/jbd/src/hello/hello.go:5)  TEXT    &quot;&quot;.main(SB), $96-0
    0x0000 00000 (/Users/jbd/src/hello/hello.go:5)  MOVQ    (TLS), CX
    0x0009 00009 (/Users/jbd/src/hello/hello.go:5)  CMPQ    SP, 16(CX)
    0x000d 00013 (/Users/jbd/src/hello/hello.go:5)  JLS 169
    0x0013 00019 (/Users/jbd/src/hello/hello.go:5)  SUBQ    $96, SP
    0x0017 00023 (/Users/jbd/src/hello/hello.go:5)  MOVQ    BP, 88(SP)
    0x001c 00028 (/Users/jbd/src/hello/hello.go:5)  LEAQ    88(SP), BP
    0x0021 00033 (/Users/jbd/src/hello/hello.go:5)  FUNCDATA    $0, gclocals路69c1753bd5f81501d95132d08af04464(SB)
    0x0021 00033 (/Users/jbd/src/hello/hello.go:5)  FUNCDATA    $1, gclocals路e226d4ae4a7cad8835311c6a4683c14f(SB)
    0x0021 00033 (/Users/jbd/src/hello/hello.go:7)  MOVQ    $2, &quot;&quot;.autotmp_1+64(SP)
    0x002a 00042 (/Users/jbd/src/hello/hello.go:7)  MOVQ    $0, &quot;&quot;.autotmp_0+72(SP)
    0x0033 00051 (/Users/jbd/src/hello/hello.go:7)  MOVQ    $0, &quot;&quot;.autotmp_0+80(SP)
    0x003c 00060 (/Users/jbd/src/hello/hello.go:7)  LEAQ    type.int(SB), AX
    0x0043 00067 (/Users/jbd/src/hello/hello.go:7)  MOVQ    AX, (SP)
    0x0047 00071 (/Users/jbd/src/hello/hello.go:7)  LEAQ    &quot;&quot;.autotmp_1+64(SP), AX
    0x004c 00076 (/Users/jbd/src/hello/hello.go:7)  MOVQ    AX, 8(SP)
    0x0051 00081 (/Users/jbd/src/hello/hello.go:7)  PCDATA  $0, $1
    0x0051 00081 (/Users/jbd/src/hello/hello.go:7)  CALL    runtime.convT2E(SB)
    0x0056 00086 (/Users/jbd/src/hello/hello.go:7)  MOVQ    16(SP), AX
    0x005b 00091 (/Users/jbd/src/hello/hello.go:7)  MOVQ    24(SP), CX
    0x0060 00096 (/Users/jbd/src/hello/hello.go:7)  MOVQ    AX, &quot;&quot;.autotmp_0+72(SP)
    0x0065 00101 (/Users/jbd/src/hello/hello.go:7)  MOVQ    CX, &quot;&quot;.autotmp_0+80(SP)
    0x006a 00106 (/Users/jbd/src/hello/hello.go:7)  LEAQ    go.string.&quot;sum: %v\n&quot;(SB), AX
    0x0071 00113 (/Users/jbd/src/hello/hello.go:7)  MOVQ    AX, (SP)
    0x0075 00117 (/Users/jbd/src/hello/hello.go:7)  MOVQ    $8, 8(SP)
    0x007e 00126 (/Users/jbd/src/hello/hello.go:7)  LEAQ    &quot;&quot;.autotmp_0+72(SP), AX
    0x0083 00131 (/Users/jbd/src/hello/hello.go:7)  MOVQ    AX, 16(SP)
    0x0088 00136 (/Users/jbd/src/hello/hello.go:7)  MOVQ    $1, 24(SP)
    0x0091 00145 (/Users/jbd/src/hello/hello.go:7)  MOVQ    $1, 32(SP)
    0x009a 00154 (/Users/jbd/src/hello/hello.go:7)  PCDATA  $0, $1
    0x009a 00154 (/Users/jbd/src/hello/hello.go:7)  CALL    fmt.Printf(SB)
    0x009f 00159 (/Users/jbd/src/hello/hello.go:8)  MOVQ    88(SP), BP
    0x00a4 00164 (/Users/jbd/src/hello/hello.go:8)  ADDQ    $96, SP
    0x00a8 00168 (/Users/jbd/src/hello/hello.go:8)  RET
    0x00a9 00169 (/Users/jbd/src/hello/hello.go:8)  NOP
    0x00a9 00169 (/Users/jbd/src/hello/hello.go:5)  PCDATA  $0, $-1
    0x00a9 00169 (/Users/jbd/src/hello/hello.go:5)  CALL    runtime.morestack_noctxt(SB)
    0x00ae 00174 (/Users/jbd/src/hello/hello.go:5)  JMP 0
    ...
</code></pre>

<p>If you would like to learn more insights about the intermediate assembly and why
it is significant in Go, I highly recommend
<a href="https://www.youtube.com/watch?v=KINIAgRpkDA">Rob Pike&rsquo;s The Design of the Go Assembler</a>
from GopherCon this year.</p>

<h3 id="disassembler">Disassembler</h3>

<p>As I mentioned, <code>-S</code> is only for the intermediate assembly. The actual machine representation is available in the final artifact.
You can use a disassembler to examine what&rsquo;s inside.
Use <code>go tool objdump</code> with a binary or library. You probably also want to use <code>-s</code> to focus by symbol name.
In this example, I am dumping the main.main. This is the actual assembly generated for <code>darwin/amd64</code>.</p>

<pre><code>$ go tool objdump -s main.main hello
TEXT main.main(SB) /Users/jbd/src/hello/hello.go
    hello.go:5  0x2040  65488b0c25a0080000  GS MOVQ GS:0x8a0, CX
    hello.go:5  0x2049  483b6110            CMPQ 0x10(CX), SP
    hello.go:5  0x204d  0f8696000000        JBE 0x20e9
    hello.go:5  0x2053  4883ec60            SUBQ $0x60, SP
    hello.go:5  0x2057  48896c2458          MOVQ BP, 0x58(SP)
    hello.go:5  0x205c  488d6c2458          LEAQ 0x58(SP), BP
    hello.go:7  0x2061  48c744244002000000  MOVQ $0x2, 0x40(SP)
    hello.go:7  0x206a  48c744244800000000  MOVQ $0x0, 0x48(SP)
    hello.go:7  0x2073  48c744245000000000  MOVQ $0x0, 0x50(SP)
    hello.go:7  0x207c  488d053d4d0800      LEAQ 0x84d3d(IP), AX
    ...
</code></pre>

<h3 id="symbols">Symbols</h3>

<p>Sometimes, all you need is to check the symbols rather than understanding code or data sections.
Similar to general-purpose nm tool, Go distributes an nm which allows you to list the symbols in an artifact with annotations and size.
Pretty handy if you want to see what&rsquo;s in and being exported from a Go binary or library.</p>

<pre><code>$ go tool nm hello
...
f4760 B __cgo_init
f4768 B __cgo_notify_runtime_init_done
f4770 B __cgo_thread_start
4fb70 T __rt0_amd64_darwin
4e220 T _gosave
4fb90 T _main
ad1e0 R _masks
4fd00 T _nanotime
4e480 T _setg_gcc
ad2e0 R _shifts
624a0 T errors.(*errorString).Error
62400 T errors.New
52470 T fmt.(*buffer).WriteRune
...
</code></pre>

<h3 id="optimizations">Optimizations</h3>

<p>With the contribution of the new SSA backend, the team contributed a tool that visualizes all the SSA passes.
Set GOSSAFUNC env variable with a func name and run the go build command.
It will generate an ssa.html file which will provide all the steps, compiler has gone through to optimize your code.</p>

<pre><code>$ GOSSAFUNC=main go build &amp;&amp; open ssa.html
</code></pre>

<p>Here, there is a visualization of all the passes applied to the main function.</p>

<p><img src="/img/ssa.png" alt="SSA optimizations" /></p>

<p>Go compiler can also annotate the inlining and escape analysis.
If you pass <code>-m=2</code> flag to the compiler, it will output the optimizations or annotations related to these two.
Here we see the <code>net/context</code> package related inlining operations and escape analysis.</p>

<pre><code>$ go build -gcflags=&quot;-m&quot; golang.org/x/net/context
# golang.org/x/net/context
../golang.org/x/net/context/context.go:140: can inline Background as: func() Context { return background }
../golang.org/x/net/context/context.go:149: can inline TODO as: func() Context { return todo }
../golang.org/x/net/context/go17.go:32: cannot inline WithCancel: non-leaf function
../golang.org/x/net/context/go17.go:46: cannot inline WithDeadline: non-leaf function
../golang.org/x/net/context/go17.go:61: cannot inline WithTimeout: non-leaf function
../golang.org/x/net/context/go17.go:62: inlining call to time.Time.Add method(time.Time) func(time.Duration) time.Time { time.t路2.sec += int64(time.d路3 / time.Duration(1000000000)); var time.nsec路4 int32; time.nsec路4 = &lt;N&gt;; time.nsec路4 = time.t路2.nsec + int32(time.d路3 % time.Duration(1000000000)); if time.nsec路4 &gt;= int32(1000000000) { time.t路2.sec++; time.nsec路4 -= int32(1000000000) } else { if time.nsec路4 &lt; int32(0) { time.t路2.sec--; time.nsec路4 += int32(1000000000) } }; time.t路2.nsec = time.nsec路4; return time.t路2 }
../golang.org/x/net/context/go17.go:70: cannot inline WithValue: non-leaf function
../golang.org/x/net/context/context.go:141: background escapes to heap
../golang.org/x/net/context/context.go:141:     from ~r0 (return) at ../golang.org/x/net/context/context.go:140
../golang.org/x/net/context/context.go:150: todo escapes to heap
../golang.org/x/net/context/context.go:150:     from ~r0 (return) at ../golang.org/x/net/context/context.go:149
../golang.org/x/net/context/go17.go:33: parent escapes to heap
../golang.org/x/net/context/go17.go:33:     from parent (passed to function[unknown]) at ../golang.org/x/net/context/go17.go:33
../golang.org/x/net/context/go17.go:32: leaking param: parent
../golang.org/x/net/context/go17.go:32:     from parent (interface-converted) at ../golang.org/x/net/context/go17.go:33
../golang.org/x/net/context/go17.go:32:     from parent (passed to function[unknown]) at ../golang.org/x/net/context/go17.go:33
../golang.org/x/net/context/go17.go:47: parent escapes to heap
../golang.org/x/net/context/go17.go:47:     from parent (passed to function[unknown]) at ../golang.org/x/net/context/go17.go:47
../golang.org/x/net/context/go17.go:46: leaking param: parent
../golang.org/x/net/context/go17.go:46:     from parent (interface-converted) at ../golang.org/x/net/context/go17.go:47
../golang.org/x/net/context/go17.go:46:     from parent (passed to function[unknown]) at ../golang.org/x/net/context/go17.go:47
../golang.org/x/net/context/go17.go:46: leaking param: deadline
../golang.org/x/net/context/go17.go:46:     from deadline (passed to function[unknown]) at ../golang.org/x/net/context/go17.go:46
../golang.org/x/net/context/go17.go:48: ctx escapes to heap
../golang.org/x/net/context/go17.go:48:     from ~r2 (return) at ../golang.org/x/net/context/go17.go:46
../golang.org/x/net/context/go17.go:61: leaking param: parent
../golang.org/x/net/context/go17.go:61:     from parent (passed to function[unknown]) at ../golang.org/x/net/context/go17.go:61
../golang.org/x/net/context/go17.go:71: parent escapes to heap
../golang.org/x/net/context/go17.go:71:     from parent (passed to function[unknown]) at ../golang.org/x/net/context/go17.go:71
../golang.org/x/net/context/go17.go:70: leaking param: parent
../golang.org/x/net/context/go17.go:70:     from parent (interface-converted) at ../golang.org/x/net/context/go17.go:71
../golang.org/x/net/context/go17.go:70:     from parent (passed to function[unknown]) at ../golang.org/x/net/context/go17.go:71
../golang.org/x/net/context/go17.go:70: leaking param: key
../golang.org/x/net/context/go17.go:70:     from key (passed to function[unknown]) at ../golang.org/x/net/context/go17.go:70
../golang.org/x/net/context/go17.go:70: leaking param: val
../golang.org/x/net/context/go17.go:70:     from val (passed to function[unknown]) at ../golang.org/x/net/context/go17.go:70
../golang.org/x/net/context/go17.go:71: context.WithValue(parent, key, val) escapes to heap
../golang.org/x/net/context/go17.go:71:     from ~r3 (return) at ../golang.org/x/net/context/go17.go:70
&lt;autogenerated&gt;:1: leaking param: .this
&lt;autogenerated&gt;:1:  from .this.Deadline() (receiver in indirect call) at &lt;autogenerated&gt;:1
&lt;autogenerated&gt;:2: leaking param: .this
&lt;autogenerated&gt;:2:  from .this.Done() (receiver in indirect call) at &lt;autogenerated&gt;:2
&lt;autogenerated&gt;:3: leaking param: .this
&lt;autogenerated&gt;:3:  from .this.Err() (receiver in indirect call) at &lt;autogenerated&gt;:3
&lt;autogenerated&gt;:4: leaking param: key
&lt;autogenerated&gt;:4:  from .this.Value(key) (parameter to indirect call) at &lt;autogenerated&gt;:4
&lt;autogenerated&gt;:4: leaking param: .this
&lt;autogenerated&gt;:4:  from .this.Value(key) (receiver in indirect call) at &lt;autogenerated&gt;:4
</code></pre>

<p>You can use <code>-m</code> to see a less verbose output without reasonings, but <a href="https://twitter.com/Dr2chase/status/788353223522455552">David Chase</a> says
even though <code>-m=2</code> is not perfect, it is often useful.</p>

<p>It is worth to mention that you often need to disable optimizations to have a simpler view of what&rsquo;s going on.
Because, optimazation can change the sequence of operations, add code, remove code or apply transformations to the code.
With optimizations, it gets harder to map a Go line to the optimized output or it gets harder to do perf testing where you end up chaging more than one thing at a time.
Disabling optimizations is possible with <code>-N</code>, and disabling inlining is possible with <code>-l</code>.</p>

<pre><code>$ go build -gcflags=&quot;-l -N&quot;
</code></pre>

<p>Once optimizations are disabled, you can debug without being affected by transformations or do perf
testing without being affected more than one change at a time.</p>

<h3 id="lexer">Lexer</h3>

<p>If you are working on the lexer, compiler provides a flag to debug
the lexer as the lexer is going through the source files.</p>

<pre><code>$ go build -gcflags=&quot;-x&quot;
# hello
lex: PACKAGE
lex: ident main
lex: implicit semi
lex: IMPORT
lex: string literal
lex: implicit semi
lex: FUNC
lex: ident main
./hello.go:5 lex: TOKEN '('
./hello.go:5 lex: TOKEN ')'
./hello.go:5 lex: TOKEN '{'
lex: ident sum
./hello.go:6 lex: TOKEN COLAS
lex: integer literal
./hello.go:6 lex: TOKEN '+'
lex: integer literal
lex: implicit semi
lex: ident fmt
./hello.go:7 lex: TOKEN '.'
lex: ident Printf
./hello.go:7 lex: TOKEN '('
lex: string literal
./hello.go:7 lex: TOKEN ','
lex: ident sum
./hello.go:7 lex: TOKEN ')'
lex: implicit semi
./hello.go:8 lex: TOKEN '}'
lex: implicit semi
</code></pre>


  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://rakyll.org/human-first/">
        Keeping Go a human-first language
      </a>
    </h1>

    <span class="post-date">Tue, Oct 11, 2016</span>

    <p><em>Disclaimer: I forked my opinions on this one from a barely readable Twitter thread
and wanted to write it down how I feel about keeping the language internals away
from the users, especially from the newcomers. This is not a skill-level concern,
it is a core goal of Go to provide a high-level programming language that saves users from
excessive mental overhead. Note that these
are personal opinons and are not writen on the behalf of a group.</em></p>

<p>Go is a highly opiniated language when it comes to API design,
readability and human-first approach.
It is critical to understand these aspects and the history of the language
before deep diving into more.</p>

<p>Go is created at Google to make engineers more productive and do more without
mental overload. Go wishes that behavior is predictable from a human perspective,
rather than humans are being enforced to think like machines to be efficient and productive.
Go sets the same high bar for its runtime. Go wishes to be good enough
to be doing the right for the most of the time &ndash; anything else can be optimized.</p>

<p>It is highly critical for us to keep Go users having
high expectations that things will work out of the box, and escalating major problems
to the team where the promise is not matching the actual behavior. Go is far away from being
a perfect language. It is important not to be sold so quickly and participate in the future of the
language if you are already skilled to understand the internals and their pitfalls.</p>

<p>I encourage our users to <a href="https://golang.org/issues/new">report bugs</a> rather than creating
extensive documentation around how to hack the current limitiations for the short-term gain.
There is much space for improvement in Go and the team desperately needs actual feedback from
actual users to commit work in the right direction.
Go needs to understand its users rather than users having to understand
every aspect of the language. This is the only scalable
approach.</p>

<p>Maybe along the way, our core goal of creating a human-first language will
be challenged, but I believe Go has proven that a language can be high-level,
precise and performant at the same time. I see no reason we should give up on this
so quickly. I apologize on the behalf of everyone involved in Go for a long time
to forget that this specific language goal needs to keep being communicated better.</p>


  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://rakyll.org/go-tool-flags/">
        Go tooling essentials
      </a>
    </h1>

    <span class="post-date">Sun, Sep 25, 2016</span>

    

<p>New to the Go tools? Or do you want to expand your knowledge? This article is
about the flags for the Go tools everyone should know.</p>

<p><em>Disclaimer: This article might be slightly biased. This is a collection of
flags I personally use and flags people around me having trouble finding references for.
If you have more ideas, ping me on <a href="https://twitter.com/rakyll">Twitter</a>.</em></p>

<h3 id="go-build-x">$ go build -x</h3>

<p><code>-x</code> lists all the commands go build invokes.</p>

<p>If you are curious about the Go toolchain, or using a cross-C compiler and
wondering about flags passed to the external compiler, or suspicious about
a linker bug; use <code>-x</code> to see all the invocations.</p>

<pre><code>$ go build -x
WORK=/var/folders/00/1b8h8000h01000cxqpysvccm005d21/T/go-build600909754
mkdir -p $WORK/hello/perf/_obj/
mkdir -p $WORK/hello/perf/_obj/exe/
cd /Users/jbd/src/hello/perf
/Users/jbd/go/pkg/tool/darwin_amd64/compile -o $WORK/hello/perf.a -trimpath $WORK -p main -complete -buildid bbf8e880e7dd4114f42a7f57717f9ea5cc1dd18d -D _/Users/jbd/src/hello/perf -I $WORK -pack ./perf.go
cd .
/Users/jbd/go/pkg/tool/darwin_amd64/link -o $WORK/hello/perf/_obj/exe/a.out -L $WORK -extld=clang -buildmode=exe -buildid=bbf8e880e7dd4114f42a7f57717f9ea5cc1dd18d $WORK/hello/perf.a
mv $WORK/hello/perf/_obj/exe/a.out perf
</code></pre>

<h3 id="go-build-gcflags">$ go build -gcflags</h3>

<p>Used to pass flags to the Go compiler. <code>go tool compile -help</code> lists all
the flags that can be passed to the compiler.</p>

<p>For example, to disable compiler optimizations and inlining, you can use
the following the gcflags.</p>

<pre><code>$ go build -gcflags=&quot;-N -l&quot;
</code></pre>

<h3 id="go-test-v">$ go test -v</h3>

<p>It provides chatty output for the testing. It prints the test name,
its status (failed or passed), how much it took to run the test, any logs
from the test case, etc.</p>

<p>go test without the <code>-v</code> flag is highly quiet, I always use it with <code>-v</code> turned on.
Sample output:</p>

<pre><code>$ go test -v context
=== RUN   TestBackground
--- PASS: TestBackground (0.00s)
=== RUN   TestTODO
--- PASS: TestTODO (0.00s)
=== RUN   TestWithCancel
--- PASS: TestWithCancel (0.10s)
=== RUN   TestParentFinishesChild
--- PASS: TestParentFinishesChild (0.00s)
=== RUN   TestChildFinishesFirst
--- PASS: TestChildFinishesFirst (0.00s)
=== RUN   TestDeadline
--- PASS: TestDeadline (0.16s)
=== RUN   TestTimeout
--- PASS: TestTimeout (0.16s)
=== RUN   TestCanceledTimeout
--- PASS: TestCanceledTimeout (0.10s)
...
PASS
ok  	context	2.426s
</code></pre>

<h3 id="go-test-race">$ go test -race</h3>

<p><a href="https://blog.golang.org/race-detector">Go&rsquo;s race detector</a> is available
from the Go tools via <code>-race</code>. go test also supports this flag and reports races.
Use this flag during development to detect the races.</p>

<h3 id="go-test-run">$ go test -run</h3>

<p>You can filter tests to run by regex and the <code>-run</code> flag. The following command
will only <a href="https://blog.golang.org/examples">test examples</a>.</p>

<pre><code>$ go test -run=Example
</code></pre>

<h3 id="go-test-coverprofile">$ go test -coverprofile</h3>

<p>You can output a cover profile as you are testing a package, then use go tool to
visualize them on a browser.</p>

<pre><code>$ go test -coverprofile=c.out &amp;&amp; go tool cover -html=c.out
</code></pre>

<p>The command above will create a coverage profile and open the results page in
the browser. The visualized results will look like the page below:</p>

<p><img src="/img/context-coverage.png" alt="context coverage" /></p>

<h3 id="go-test-exec">$ go test -exec</h3>

<p>It is a lesser known feature in Go that you can intercept the tools with another
program by using the <code>-exec</code> flag. This flag allows you to delegate some work to an
external program from the Go tool.</p>

<p>A commonly required scenario for this flag is when you need more than just executing
the tests on the host machine. The Android builder for Go, uses <code>-exec</code> to push the
test binaries to an Android device by using <code>adb</code> and collects the results.
<a href="https://github.com/golang/go/blob/master/misc/android/go_android_exec.go">Android exec program</a>
can be used as a reference.</p>

<h3 id="go-get-u">$ go get -u</h3>

<p>If you run go-get for a package that is already in your GOPATH, go-get
is not going to update the package to its latest version.
<code>-u</code> forces the tool to sync with the latest version of the repo.</p>

<p>If you are a library author, you might like to write your installation
instructions with a <code>-u</code> flag, e.g. the way <a href="https://github.com/golang/lint#installation">golint</a> does.</p>

<pre><code>$ go get -u github.com/golang/lint/golint
</code></pre>

<h3 id="go-get-d">$ go get -d</h3>

<p>If you just want to clone a repo to your GOPATH and skip the building
and installation phase, use <code>-d</code>. It downloads the package and stops
before trying to build or install it.</p>

<p>I often use it as a replacement for git clone for repos with vanity URLs,
because it clones the repo to its proper GOPATH.
For example,</p>

<pre><code>$ go get -d golang.org/x/oauth2/...
</code></pre>

<p>will clone the package to $GOPATH/src/golang.org/x/oauth2. Given golang.org/x/oauth2 is a
vanity URL, go-getting the repo is useful rather than trying to figure out
where the actual repo is (go.googlesource.com/oauth2).</p>

<h3 id="go-get-t">$ go get -t</h3>

<p>If your package has additional dependencies for tests, <code>-t</code> will allow you to
download them during go-get.
If you don&rsquo;t pass <code>-t</code>, go get will only download the dependencies for your non-test code.</p>

<h3 id="go-list-f">$ go list -f</h3>

<p>Allows you to list Go packages with a custom format. It is highly useful
for writing bash scripts.</p>

<p>The following command will print the dependencies of the runtime package:</p>

<pre><code>go list -f '{{.Deps}}' runtime
[runtime/internal/atomic runtime/internal/sys unsafe]
</code></pre>

<p>More formatting ideas can be found at
<a href="http://dave.cheney.net/2014/09/14/go-list-your-swiss-army-knife">Dave Cheney&rsquo;s article</a> on <code>go list</code>.</p>


  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://rakyll.org/examples-coverage/">
        Examples coverage
      </a>
    </h1>

    <span class="post-date">Thu, Sep 8, 2016</span>

    <p>Go programming language provides many unique good features to <a href="https://blog.golang.org/examples">
write and maintain examples</a> for your packages backed by the testing tools.</p>

<p>As an addition to the test coverage and test coverage report, <code>go test</code>
also can provide coverage for testable examples.</p>

<p>Use the following commands in your package to use the
<code>-run</code> flag to only the match the example tests and view the results
in your browser.</p>

<pre><code>$ go test -v -run=Example -coverprofile=c.out &amp;&amp; go tool cover -html=c.out
</code></pre>

<p>Please note that the coverage is reported for Examples with an Output block.
Examples without an &ldquo;Output&rdquo; block will not be tested and reported.</p>

<p>Here is what the <a href="/att/example-coverage.html">coverage</a> looks like
for the strings package from the stdlib.</p>

<p>High example coverage is probably not a neccesary signal
and not all lines are supposed to be documented with an example
but it might give you an idea whether you are missing out a significant
non-obvious case that needs to be documented
more comphensively.</p>


  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://rakyll.org/parallelize-test-tables/">
        Parallelize your table-driven tests
      </a>
    </h1>

    <span class="post-date">Tue, Sep 6, 2016</span>

    <p>With Go 1.7, testing package supports sub-tests that allows you to run
multiple smaller tests from a test case. Each sub test is reported
independently in the <code>go test</code> output. More information about these
recent additions can be found at <a href="https://speakerdeck.com/mpvl/advanced-testing-concepts-for-go-1-dot-7">Marcel van Lohuizen&rsquo;s recent talk</a>
from GolangUK 2016.</p>

<p>These additions to Go 1.7 enabled reporting and other testing.T
functionality for subtests. One of the biggest contributions of the
recent changes is to be able to use these features for table-driven tests.</p>

<p>The other important feature it enables is to be able to parallize the
subtests (where makes sense) by using (*testing.T).Parallize().</p>

<pre><code class="language-go">func TestFoo(t *testing.T) {
	tc := []struct {
		dur time.Duration
	}{
		{time.Second},
		{2 * time.Second},
		{3 * time.Second},
		{4 * time.Second},
	}
	for _, tt := range tc {
		tt := tt
		t.Run(&quot;&quot;, func(st *testing.T) {
			st.Parallel()
			time.Sleep(tt.dur)
		})
	}
}
</code></pre>

<p>The test suite above will run roughly in 4 seconds rather than 10 seconds.
TestFoo#01, TestFoo#02, TestFoo#03 and TestFoo#04 will begin at the same
time, will wait for <code>tt.dur</code> and be completed.</p>

<pre><code>$ go test -v
=== RUN   TestFoo
=== RUN   TestFoo/#00
=== RUN   TestFoo/#01
=== RUN   TestFoo/#02
=== RUN   TestFoo/#03
--- PASS: TestFoo (0.00s)
    --- PASS: TestFoo/#00 (1.00s)
    --- PASS: TestFoo/#01 (2.00s)
    --- PASS: TestFoo/#02 (3.00s)
    --- PASS: TestFoo/#03 (4.00s)
PASS
ok  	hello/subtests	4.020s
</code></pre>

<p>If you have table driven that are free from races and are majorly blocked
by anything other than your CPU, consider parallelizing them with the new sub tests.</p>


  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://rakyll.org/instruments/">
        Using Instruments to profile Go programs
      </a>
    </h1>

    <span class="post-date">Fri, Sep 2, 2016</span>

    <p>Apple has a suite of instrumentation and tracing tools for performance
analysis avaiable as a part of their Xcode tooling set. In this article,
we will use <a href="https://developer.apple.com/library/prerelease/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/">Instruments</a>
to record and analyze the CPU profile of a Go program.</p>

<p>Instruments also provide a large set of macOS-specific tracing and profiling
if you have performance issues specifically on darwin.</p>

<p>Some of these specific profiles are:</p>

<ul>
<li>System trace: Collects comprehensive information about system calls,
scheduling, user-kernel space transitions. (Available only on OSX.)</li>
<li>System usage: Gives very detailed output about I/O system activity.
(Available only on iOS.)</li>
<li>File Activity: Monitors file and directory activity such as open/close,
permission modifications, creation, copying and moving.</li>
</ul>

<p>Instruments provide a rich and very easy to use UI to display profiles.
I highly recommend it as an addition to existing profiler UIs and vizualizers.</p>

<p>Now, let&rsquo;s profile a Go program.</p>

<p>Launch the Instruments app and select &ldquo;Time Profiler&rdquo;.</p>

<p>Create a target with your Go binary and arguments and env variables
you want to start the binary with. In this tutorial, I will use the
following program.</p>

<pre><code>go get -u github.com/rakyll/hey
</code></pre>

<p>We will use <code>hey</code> to make 10000 requests with 200 goroutines
to the target provided in the arguments.</p>

<p>The target I have for <code>hey</code> looks like what&rsquo;s below.</p>

<p><img src="/img/instruments-target.png" alt="Instruments target" /></p>

<p>Once you have a target, you can click on the record button to start
recording samples. Once enough samples are collected, stop or it will
eventually stop when the program finishes.</p>

<p><img src="/img/instruments-results.png" alt="Instruments results" /></p>

<p>You can filter by symbol name, user vs kernel callstacks, time span,
physical or logical CPU and more. You can also double click any of the symbols listed
to jump to the source code.</p>

<p>Please note that Go programs cannot work with every profile available
on Instruments. But there are a few profiles that absolutely can improve
your profiling experience. With stack frame pointers enabled by default in Go 1.7,
it became easier for tools like Instruments to capture backtraces more efficiently.</p>

<p>Happy profiling!</p>


  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://rakyll.org/grpc-streaming/">
        Bidirectional gRPC streaming for Go
      </a>
    </h1>

    <span class="post-date">Tue, Aug 30, 2016</span>

    <p><em>Disclaimer: This article is not about a core Go package or tool but <a href="http://www.grpc.io/">gRPC</a>.</em></p>

<p>gRPC provides support for implementing streaming endpoints as well as
streaming support in their clients. Bidirectional streaming is useful
if you want both server and client to be able to communicate
to the other side independently in a full duplex fashion.</p>

<p>In this article, I will dig into how to use the streaming gRPC
Go client to talk to a streaming API endpoint.</p>

<p>I am not expecting the readers to implement a server, hence I will use an
existing service.
Google has recently realeased the <a href="https://cloud.google.com/speech/">Cloud Speech API</a>
which allows its users
to caption their audio input. Speech API also supports a bidirectional
streaming endpoint where you can sent audio data continously as you are
waiting on more responses from the server on another incoming channel.</p>

<p>Initialize a client:</p>

<pre><code class="language-go">stream, err := speech.NewSpeechClient(conn).StreamingRecognize(ctx)
if err != nil {
    log.Fatal(err)
}
</code></pre>

<p>We want to pipe the stdin to the API as we are printing the results.
Therefore, we will need two goroutines, one sending audio data to the
service and another retrieving the results.</p>

<p>The program will read from os.Stdin into an intermediate buffer and
will immediately push the buffer to the service.</p>

<pre><code class="language-go">go func() {
    // pipe stdin to the API
    buf := make([]byte, 1024)
    for {
        n, err := os.Stdin.Read(buf)
        if err == io.EOF {
            return // nothing else to pipe, kill this goroutine
        }
        if err != nil {
            // TODO: handle the error
            continue 
        }
        if err = stream.Send(&amp;speech.StreamingRecognizeRequest{
            StreamingRequest: &amp;speech.StreamingRecognizeRequest_AudioContent{
                AudioContent: buf[:n],
            },
        }); err != nil {
            // TODO: handle the error
        }
    }
}()
</code></pre>

<p>At the same time, the program will start reading the responses in the
main goroutine and print the captions as service pushes them:</p>

<pre><code class="language-go">for {
    resp, err := stream.Recv()
    if err == io.EOF {
        break
    }
    if err != nil {
        // TODO: handle the error
        continue
    }
    if resp.Error != nil {
        // TODO: handle the error
        continue
    }
    for _, result := range resp.Results {
        fmt.Printf(&quot;result: %+v\n&quot;, result)
    }
}
</code></pre>

<p>The full reference is living in a <a href="https://gist.github.com/rakyll/e7082fdcbdb18ee32997aa602ca164d6">gist</a>
where you can learn more about the initializing of the gRPC connection and more.</p>

<p>Please note that the same pattern of sending and receiving can be applied to
work with any gRPC bidirectional streaming client.</p>


  </div>
  
  
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://rakyll.org/eg/">
        Apply transformations to Go code with eg
      </a>
    </h1>

    <span class="post-date">Sat, Aug 27, 2016</span>

    <p>If you are willing to make large scale refactoring in your
Go programs, automating the refactoring tasks is more desirable than
manual editing. <code>eg</code> is a program that allows you to perform transformations
based on template Go files.</p>

<p>To install the tool, run the following:</p>

<pre><code>$ go get golang.org/x/tools/cmd/eg
</code></pre>

<p><code>eg</code> requires a template file to look for which transformation it should
apply to your source code. What&rsquo;s nice is that the template file is a Go file
with little annotations.</p>

<p>Consider the following Go program:</p>

<pre><code class="language-go">$ cat $GOPATH/src/hello/hello.go
package hello

import &quot;time&quot;

// ExtendWith50000ns adds 50000ns to t.
func ExtendWith50000ns(t time.Time) time.Time {
	return t.Add(time.Duration(50000))
}
</code></pre>

<p>Assume you want to eliminate the unnecessary time.Duration casting at ExtendWith50000ns
and as a good practice, you would also like to add a unit to the duration rather than
just passing 50000.</p>

<p><code>eg</code> requires a template file where you define before and afters that represents the
transformation.</p>

<pre><code class="language-go">$ cat T.template
package template

import (
    &quot;time&quot;
)

func before(t time.Time, d time.Duration) time.Time {
    // if already time.Duration, do not cast.
    return t.Add(time.Duration(d))
}

func after(t time.Time, d time.Duration) time.Time  {
    return t.Add(d * time.Nanosecond)
}
</code></pre>

<p>And run the <code>eg</code> command on your hello package to apply it at every occurrence of this pattern.</p>

<pre><code>$ eg -w -t T.template hello
=== /Users/jbd/src/hello/hello.go (1 matches)
</code></pre>

<p>Voila!</p>

<p>The file now contains a duration that is not casted unnecessarily and it has a unit.</p>

<pre><code class="language-go">$ cat $GOPATH/src/hello/hello.go
package hello

import &quot;time&quot;

// ExtendWith50000ns adds 50000ns to t.
func ExtendWith50000ns(t time.Time) time.Time {
	return t.Add(50000 * time.Nanosecond)
}
</code></pre>

<p>Note: There are many <a href="https://github.com/golang/tools/tree/master/refactor/eg/testdata">.template files</a>
underneath the package for testing purposes but they can also be used as a
reference how to write other transformation templates.</p>


  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://rakyll.org/swift/">
        Calling Go from Swift
      </a>
    </h1>

    <span class="post-date">Sat, Oct 3, 2015</span>

    <p><em>Note: Swift bindings are highly experimental and subject to change.
This work must currently be classified as preliminary work and we will
be improving APIs in the long term.</em></p>

<p>As a part of the Go Mobile, we have announced tools and packages that
make language bindings from Java to Go and Objective-C to Go available.
A relatively new and less documented aspect of the bindings is the
availability of the Swift to Go calls. This tutorial will explain you
how to make your initial Swift to Go function invocation.</p>

<p>Grab the gomobile command and initialize it.</p>

<pre><code>$ go get golang.org/x/mobile/cmd/gomobile
$ gomobile init
</code></pre>

<p>In this tutorial, we will use an example Go package from the mobile repo
called hello to generate bindings for. The hello package exports a function
called Greetings and we will invoke this particular function from a
Swift-based iOS app. Go get the example hello package and run <code>gomobile bind</code>
to generate a framework bundle.</p>

<pre><code>$ go get golang.org/x/mobile/example/bind/hello/...
$ gomobile bind -target=ios golang.org/x/mobile/example/bind/hello
</code></pre>

<p>The command above is going to generate a bundle called Hello.framework on the
current working directory which includes a multi-arch C library and a header file.</p>

<p>The next step is to launch Xcode and open your existing Swift-based iOS app project.
Drag and drop the Hello.framework to the project.
This step will also automatically make the framework library linked to the final app product.</p>

<p><img src="/img/swift-xcode.png" alt="Xcode drag and drop" /></p>

<p>Once the framework bundle is imported, you are good to import the
Hello module and invoke GoHelloGreetings which is a proxy function for
hello.Greetings.</p>

<pre><code>import UIKit
import Hello
class ViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        println(Hello.GoHelloGreetings(&quot;gopher&quot;))
    }
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
    }
}
</code></pre>

<p>Build and run it on your test device or the iOS simulator.
Enjoy making your first call to Go from Swift. Please note that this is
preliminary work and we would like to make changes to improve the APIs in the long term.
More information and tutorials about Go Mobile are available at
the <a href="https://golang.org/wiki/Mobile">wiki</a>.</p>


  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://rakyll.org/cross-compilation/">
        Go cross compilation
      </a>
    </h1>

    <span class="post-date">Tue, Sep 8, 2015</span>

    

<p>Note: This article extends <a href="http://dave.cheney.net/2015/03/03/cross-compilation-just-got-a-whole-lot-better-in-go-1-5">Dave Cheneys Go 1.5 cross compilers</a> post.</p>

<p>Cross compilers got easier with Go 1.5.
You dont have to bootstrap the standard library and toolchain as you
used to do prior to 1.5.</p>

<h3 id="if-cgo-is-not-required">If cgo is not required</h3>

<p>The go tool wont require any bootstrapping if cgo is not required.
That allows you to target the following program to any GOOS/GOARCH without
requiring you to do any additional work. Invoke <code>go build</code>.</p>

<pre><code>$ cat main.go
package main
import &quot;fmt&quot;
func main() {
    fmt.Println(&quot;hello world&quot;)
}
</code></pre>

<p>In order to target android/arm, run the following command.</p>

<pre><code>$ GOOS=android GOARCH=arm GOARM=7 go build .
</code></pre>

<p>The produced binary is targeting ARMv7 processors that runs Android.
All possible GOOS and GOARCH values are listed on the <a href="https://golang.org/doc/install/source#environment">environment docs</a>.</p>

<h3 id="if-cgo-is-required">If cgo is required</h3>

<p>If you need to have cgo enabled, the go tool allows you to provide
custom C and C++ compilers via CC and CXX environment variables.</p>

<pre><code>$ CGO_ENABLED=1 CC=android-armeabi-gcc CXX=android-armeabi-g++ \
    GOOS=android GOARCH=arm GOARM=7 go build .
</code></pre>

<p>The toolchain will invoke android-armeabi-gcc and android-armeabi-g++
if it is required to compile any part of the package with a C or C++ compiler.
Consider the following program with a slightly different main function.
Rather than outputting &ldquo;hello world&rdquo; to the standard I/O,
it will use Android system libraries to write &ldquo;hello world&rdquo; to the system log.</p>

<pre><code>$ cat main.go
// +build android

package main

// #cgo LDFLAGS: -llog
//
// #include &lt;android/log.h&gt;
//
// void hello() {
//   __android_log_print(
//     ANDROID_LOG_INFO, &quot;MyProgram&quot;, &quot;hello world&quot;);
// }
import &quot;C&quot;
func main() {
    C.hello()
}
</code></pre>

<p>If you build the program with the command above and examine the build
with -x, you can observe that cgo is delegating the C compilation to
arm-linux-androideabi-gcc.</p>

<pre><code>$ CGO_ENABLED=1 \
CC=arm-linux-androideabi-gcc \
CXX=arm-linux-androideabi-g++ \
GOOS=android GOARCH=arm GOARM=7 go build -x .
...
CGO_LDFLAGS=-g -O2 -llog /Users/jbd/go/pkg/tool/darwin_amd64/cgo -objdir $WORK/github.com/rakyll/hello/_obj/ -importpath github.com/rakyll/hello  -I $WORK/github.com/rakyll/hello/_obj/ main.go
arm-linux-androideabi-gcc -I . -fPIC -marm -pthread -fmessage-length=0 -print-libgcc-file-name
arm-linux-androideabi-gcc -I . -fPIC -marm -pthread -fmessage-length=0 -I $WORK/github.com/rakyll/hello/_obj/ -g -O2 -o $WORK/github.com/rakyll/hello/_obj/_cgo_main.o -c $WORK/github.com/rakyll/hello/_obj/_cgo_main.c
...
</code></pre>

<h3 id="pre-building-the-standard-library">Pre-building the standard library</h3>

<p>The go tool also provides a utility if you would like to pre-build the
standard library, targeting a specific GOOS and GOARCH.</p>

<pre><code>$ CGO_ENABLED=1 \
    CC=arm-linux-androideabi-gcc \
    CXX=arm-linux-androideabi-g++ \
    GOOS=android GOARCH=arm GOARM=7 go install std
</code></pre>

<p>The standard library targeting android/armv7 will be available at $GOROOT/pkg/android_arm.</p>

<pre><code>$ ls $GOROOT/pkg/android_arm
archive    fmt.a      math       runtime.a
bufio.a    go         math.a     sort.a
bytes.a    hash       mime       strconv.a
compress   hash.a     mime.a     strings.a
container  html       net        sync
crypto     html.a     net.a      sync.a
crypto.a   image      os         syscall.a
database   image.a    os.a       testing
debug      index      path       testing.a
encoding   internal   path.a     text
encoding.a io         reflect.a  time.a
errors.a   io.a       regexp     unicode
expvar.a   log        regexp.a   unicode.a
flag.a     log.a      runtime
</code></pre>

<p>If you prefer not to pre-build and install the standard library to the GOROOT,
required libraries will be built while building user packages.
But, the standard libraries builds are not preserved for future use at this
stage and they will be rebuilt each time you run <code>go build</code>.</p>


  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://rakyll.org/interface-pollution/">
        Interface pollution in Go
      </a>
    </h1>

    <span class="post-date">Sat, Oct 18, 2014</span>

    <p>If there was a single powerful language feature in Go, itd be the interfaces.
The internals of Go contain strong combinations of useful ideas from various type
systems and inevitably they ring the curiosity bells. I recently surveyed Github
for Go interface declarations, and the results indicated that Go users pollute
the environment with interfaces no one needs or will use.</p>

<p>Dont export any interfaces until you have to.</p>

<p>Interfaces are great, but interface pollution is not so. Youre likely to come to
Go from a language (if not from a dynamic language) that generates a static dispatch
table during compilation, the compiler require you to explicitly tell the interfaces
a type wants to implement. Thats how the complier can generate a vtable with pointers
to all available virtual functions. If your background is in C++ or Java, youre likely
to have some baggage around initiating your codebase with abstract types and work on the
concrete implementation as a follow-up exercise. This is not how you do it in Go.
Introduce concrete types and dont export any interfaces unless you have to encourage
external packages to implement one. io package is a good starting point to study some
of the the best practices. It exports interfaces because it also needs to export
generic-use functions like Copy.</p>

<pre><code>func Copy(dst Writer, src Reader) (written int64, err error)
</code></pre>

<p>Should your package export generic functionality? If the answer is a maybe,
youre likely to be polluting your package with an interface declaration.
Justify the need of multiple implementations, likeliness of them to interact
back with your package and act accordingly.</p>

<p>Go doesnt have a traditional dispatch table, and can rely on the interface values
during a method dispatch. Its literally more of a freestyle dispatcher mechanism
that requires some work during interface value assignmentit generates a tiny lookup
hash-table for the concrete type its pointing to. The assignment is not insanely
expensive, so its a fair exchange for a more pleasant type system.
Ian Lance Taylor has <a href="http://www.airs.com/blog/archives/277">a great blog post about the internals</a>
if youre looking for further reading.</p>

<p>If a user requires some level of inversion of control, an on-the-fly interface
definition in their own scope would just work. This possibility minimizes the
presumptions you have to make about the way your package is being consumed and
the initial abstractions you have to work on.</p>

<p>It also applies to the testability concerns, you dont have to provide interfaces
to help the user to write their own stubs. Earlier today, I got a request to export
an interface from the pubsub package to make it more mockable. Rather than doing so,
the preferable way is to tell your user to introduce an interface that focuses on the
calls they want to write a stub for. Point to the actual implementation via an interface value.</p>

<pre><code>type acknowledger interface {
    Ack(sub string, id ...string) error
}

type mockClient struct{}

func (c *mockClient) Ack(sub string, id ...string) error {
    return nil
}

var acker acknowledger = pubsub.New(...)

acker = &amp;mockClient{} // in the test package
</code></pre>

<p>Noteworthy that, in Go, the standard library defines tiny interfaces you happen to
implement without effort and is doing a good job at encouraging the developers to write
compatible code with the rest of the standard libraryand the other third party packages.
Adopt whats available in the standard library where possible and document accordingly.</p>

<p>Go fascinates me each time I deeply reevaluate my experience with the interfaces.
Given the chance of minimal fragmentation in interfaces, this is how a programming
language make software, that isnt designed to work together, work well together.</p>


  </div>
  
  
  
  
</div>
</div>

  </body>
</html>
